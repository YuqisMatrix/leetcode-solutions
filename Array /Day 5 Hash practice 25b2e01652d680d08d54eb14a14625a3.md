# Day 5 Hash practice

# 1. 242 Valid Anagram

https://leetcode.com/problems/valid-anagram/submissions/1748478186/

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

**Example 1:**

**Input:** s = "anagram", t = "nagaram"

**Output:** true

**Example 2:**

**Input:** s = "rat", t = "car"

**Output:** false

**Constraints:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` and `t` consist of lowercase English letters.

**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        return set(s) == set(t)
```

问题在哪里？ 

### 问题

`set(s)` 只关心 **有哪些不同的字符**，**不关心字符出现的次数**。

但是 **anagram 的定义**是：两个字符串包含的所有字符 **种类和频次**都要一致。

```python
s = "aab"
t = "ab"
print(set(s))  # {'a', 'b'}
print(set(t))  # {'a', 'b'}

```

```python
set(s) == set(t) → True ❌
但其实 "aab" 和 "ab" 并不是 anagram（一个有两个 'a'，另一个只有一个 'a'）
```

### Solution:

**数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数

再遍历 字符串s的时候，**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。** 这样就将字符串s中字符出现的次数，统计出来了。

那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。

那么最后检查一下，**record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。**

最后如果record数组所有元素都为零0，说明字符串s和t是字母异位词，return true。

时间复杂度为O(n)，空间上因为定义是的一个常量大小的辅助数组，所以空间复杂度为O(1)。

```python
from collections import defaultdict
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        #print(ord("a")) : 97
        freq = [0] * 26 
        for chr in s:
            freq[ord(chr) - ord("a")] += 1
        for chr in t:
            freq[ord(chr) - ord("a")] -= 1
        for i in range(26):
            if freq[i] != 0:
                return False 
        return True
```

time complexity : o(n)， space complexity: o(n). 

## Follow-Up: Unicode Characters

```python
from collections import defaultdict
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        dic_s = defaultdict(int)
        dic_t = defaultdict(int)
        for chr in s:
            dic_s[chr] += 1
        for chr in t:
            dic_t[chr] += 1
        return dic_s == dic_t
```

If the strings contain **Unicode characters** (e.g., Chinese, emoji, accented letters), the **26-length array approach won’t work**, because the character set is unbounded.

Instead, we should use a **hash table (dictionary / Counter in Python)** to count characters.

### Unicode-Safe Approach

```python
from collections import Counter

def isAnagram(s: str, t: str) -> bool:
    return Counter(s) == Counter(t)

```

- Works for **any Unicode characters**
- Still **O(n)** time, but space complexity depends on the number of unique characters.

---

# 2. 349 intersection of two arrays

Given two integer arrays `nums1` and `nums2`, return *an array of their intersection*. Each element in the result must be **unique** and you may return the result in **any order**.

**Example 1:**

```
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

```

**Example 2:**

```
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

```

直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。

不要小瞧 这个耗时，在数据量大的情况，差距是很明显的。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        ans = set()
        nums1_set = set(nums1)
        for num in nums2:
            if num in nums1_set:
                ans.add(num)
        return list(ans)
```

```python
return list(set(nums1) & set(nums2))
```

time complexity: O(m+n), space: O(m+n)

---

# 3. 202 Happy Number

https://leetcode.com/problems/happy-number/description/

Write an algorithm to determine if a number `n` is happy.

A **happy number** is a number defined by the following process:

- Starting with any positive integer, replace the number by the sum of the squares of its digits.
- Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.
- Those numbers for which this process **ends in 1** are happy.

Return `true` *if* `n` *is a happy number, and* `false` *if not*.

**Example 1:**

```
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

```

**Example 2:**

```
Input: n = 2
Output: false
```

# 心得：

loop 到底什么时候停止？ 要怎么get sum？ 

### method1:  using set and a helper function

- helper function get_sum to get the sum of squares of the digits of n.
- 用 `while True` 循环不断更新 `n`
    - get a new sum
    - if the new sum is 1, then it is happy number
    - if the new sum is already in the set, then it is not happy number
    - if new sum is not in the set, then we add it to the set and get the new sum

```python
class Solution:
    def isHappy(self, n: int) -> bool:
        sum_set = set()
        while True:
            s = self.get_sum(n)
            if s == 1:
                return True 
            if s in sum_set:
                return False 
            sum_set.add(s)
            #print(s)
            n = s
    def get_sum(self, n):
        sum1 = 0
        while n :
            digit = n % 10 
            sum1 += digit ** 2 
            n //= 10 
        return sum1
```

### method2: use string to get the sum of squares of the digits

- while n is not in the set,
    - we add it to the set,
    - and get the sum of the squares of the digits.
    - if the new sum is one, then it is happy number
    - if the new sum is not one, we make n = new sum and repeat the process

```python

class Solution:
    def isHappy(self, n: int) -> bool:
            sum_set = set()
            while n not in sum_set:
                sum_set.add(n)
                sum1 = 0
                n_str = str(n)
                #print(n_str)
                for chr in n_str:
                    sum1 += int(chr) ** 2 
                if sum1 == 1:
                    return True 
                else:
                    n = sum1
            return False
```

- 时间复杂度: O(logn)
- 空间复杂度: O(logn

---

# 4. 2 sum

https://leetcode.com/problems/two-sum/description/

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have ***exactly* one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]

```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]

```

**Constraints:**

- `2 <= nums.length <= 104`
- `109 <= nums[i] <= 109`
- `109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:**

Can you come up with an algorithm that is less than

```
O(n2)
```

time complexity?

## 心得

1. 什么时候用hash？要判断这个元素是否出现过，是否在这个元素出现过。 

要判断一下target - num 是否在集合出现过。 

1. 要返回index 所以要用enumerate来存index and target - num. 要存两个元素 所以 要用map 来存。 具体说是要用value 当key， index 当value 

## 为什么？

我们要找元素是否出现过， 所以要把这个元素当成key。因为map可以在最快时间内查找key 是否在这个map 里出现过。 所以元素是key， index 是 value。 

1. **map的功能是存放我们遍历过的元素**

比如

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

当我们遍历到2， 7 还不在map 里，把2: 0 放进map 里， 然后遍历到7，元素2 已经遍历过了，所以可以查询到. 

## 逻辑很重要， 这个问题这次写还是出现了

循环的顺序很重要 是先check 元素在不在dict， 还是先把元素添加进 map？ 逻辑很重要， 我们得先check， 因为如果num 正好是 target 的一半， 要是先添加， 那target - num 已经在map 里了， 会return当前的角标两次。 

所以要先check 在不在map 里 如果在， return index， 如果不在， add to map

```python
from collections import defaultdict
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = dict()
        for i, num in enumerate(nums):
            if target - num in dic:
                return [i, dic[target-num]]
            dic[num] = i 
        return False
```

- 时间复杂度: O(n)
- 空间复杂度: O(n)